<template>
  <div class="page">
    <div class="navbar">
      <div class="navbar-inner">
        <div class="left"><a href="#" class="back link">Back</a></div>
        <div class="title">Profile</div>
        <div class="right">
          <a href="#" class="edit-toggle">Edit</a>
        </div>
      </div>
    </div>
    <div class="page-content">
      <div
        id="profile-room-content"
        style="padding: 1rem; font-family: sans-serif"
      >
        Loading profile...
      </div>
    </div>
  </div>
</template>

<script>
  import store, { getCachedUser } from "../js/store.js";

  async function loadProtectedImage(url, token, imgElement) {
    try {
      const res = await fetch(url, {
        headers: { Authorization: `Bearer ${token}` },
      });
      if (!res.ok) throw new Error("Failed to load image");
      const blob = await res.blob();
      imgElement.src = URL.createObjectURL(blob);
    } catch {
      imgElement.src = "/default-pfp.svg";
    }
  }

  export default (props, { $, $onMounted, $f7route }) => {
    let originalRoomHtml = "";
    let editMode = false;
    let currentUserData = {};

    const renderCustomTags = async (container, username, userData) => {
      const token = store.state.token;
      const server = store.state.server;

      container.querySelectorAll("pf-avatar").forEach(async (tag) => {
        const wrapper = document.createElement("div");
        wrapper.className = "pf-avatar";

        const img = document.createElement("img");
        img.className = "pf-avatar";
        img.alt = username;
        img.src = "/default-pfp.svg";

        if (userData?.avatar) {
          const url = `${server}/avatar/${userData.avatar}`;
          await loadProtectedImage(url, token, img);
        }

        wrapper.appendChild(img);
        tag.replaceWith(wrapper);
      });

      container.querySelectorAll("pf-banner").forEach((tag) => {
        const wrapper = document.createElement("div");
        wrapper.className = "pf-banner";

        if (userData?.banner) {
          const img = document.createElement("img");
          img.src = `${server}/banner/${userData.banner}`;
          img.className = "pf-banner-img";
          wrapper.appendChild(img);
        } else {
          wrapper.textContent = "No banner set";
        }

        tag.replaceWith(wrapper);
      });

      container.querySelectorAll("pf-feed").forEach(async (tag) => {
        try {
          const res = await fetch(`${server}/my_uploads`, {
            headers: { Authorization: `Bearer ${token}` },
          });
          const feed = await res.json();
          const wrapper = document.createElement("div");
          wrapper.className = "pf-feed-grid";

          feed.reverse().forEach((item) => {
            const video = document.createElement("video");
            video.controls = true;
            video.src = `${server}/uploads/${item.filename}`;
            Object.assign(video.style, {
              maxWidth: "100%",
              marginTop: "1rem",
            });
            wrapper.appendChild(video);
          });

          tag.replaceWith(wrapper);
        } catch {
          tag.replaceWith(document.createTextNode("Unable to load feed."));
        }
      });
    };

    function enterEditMode(container) {
      const room = container.querySelector(".pf-room");
      if (!room) return;

      [...room.children].forEach((child) => {
        // Skip already wrapped or pf-banner
        if (
          child.classList.contains("edit-block") ||
          child.classList.contains("pf-banner")
        )
          return;

        // Handle bio specifically
        if (child.querySelector("pf-bio")) {
          const textarea = document.createElement("textarea");
          textarea.id = "edit-bio";
          textarea.value = child.querySelector("pf-bio").textContent.trim();
          const wrapper = document.createElement("div");
          wrapper.className = "edit-block";
          wrapper.style.marginBottom = "1rem";
          wrapper.appendChild(textarea);
          child.replaceWith(wrapper);
          return;
        }

        // All other moveable elements
        const wrapper = document.createElement("div");
        wrapper.className = "edit-block";
        wrapper.draggable = true;
        wrapper.style.border = "2px dashed #007aff";
        wrapper.style.padding = "0.75rem";
        wrapper.style.marginBottom = "1rem";
        wrapper.style.cursor = "move";

        // Save the tag for later restore
        let tagName = "";
        if (child.classList.contains("pf-avatar")) tagName = "pf-avatar";
        else if (child.classList.contains("pf-feed-grid")) tagName = "pf-feed";
        wrapper.dataset.tag = tagName;

        wrapper.appendChild(child.cloneNode(true));
        child.replaceWith(wrapper);

        // Enable drag
        wrapper.ondragstart = (e) => {
          room.dragged = wrapper;
          e.dataTransfer.setData("text/plain", "");
        };
        wrapper.ondragover = (e) => e.preventDefault();
        wrapper.ondrop = (e) => {
          e.preventDefault();
          if (room.dragged && room.dragged !== wrapper) {
            room.insertBefore(room.dragged, wrapper.nextSibling);
          }
        };
      });
    }

    async function saveEdits(container) {
      const room = container.querySelector(".pf-room");
      if (!room) return;

      const cleanRoom = document.createElement("div");
      cleanRoom.className = "pf-room";
      cleanRoom.style.textAlign = "center";
      cleanRoom.style.padding = "2rem";

      // Rebuild the content from edit blocks
      [...room.children].forEach((block) => {
        if (block.classList.contains("edit-block")) {
          const tag = block.dataset.tag;
          if (tag === "pf-name" || tag === "pf-bio") {
            if (block.querySelector("#edit-bio")) {
              const bio = document.createElement("pf-bio");
              bio.textContent = block.querySelector("#edit-bio").value;
              const p = document.createElement("p");
              p.appendChild(bio);
              cleanRoom.appendChild(p);
              return;
            }

            const el = document.createElement(tag);
            el.innerHTML = block.innerText.trim();
            const wrapper = document.createElement(
              tag === "pf-name" ? "h1" : "p"
            );
            wrapper.appendChild(el);
            cleanRoom.appendChild(wrapper);
          } else if (tag) {
            const el = document.createElement(tag);
            cleanRoom.appendChild(el);
          } else {
            cleanRoom.appendChild(block.firstElementChild.cloneNode(true));
          }
        } else {
          cleanRoom.appendChild(block.cloneNode(true));
        }
      });

      // Wrap and combine <style> tags with content
      const wrapper = document.createElement("div");
      wrapper.appendChild(cleanRoom);

      // Capture original <style> tags and prepend them to the final HTML
      const styles = [...container.querySelectorAll("style")].map(
        (s) => s.outerHTML
      );
      const newHtml = styles.join("") + wrapper.innerHTML;

      const form = new URLSearchParams();
      form.append("html", newHtml);

      await fetch(`${store.state.server}/room/save`, {
        method: "POST",
        headers: {
          Authorization: `Bearer ${store.state.token}`,
          "Content-Type": "application/x-www-form-urlencoded",
        },
        body: form.toString(),
      });
    }

    $onMounted(async () => {
      const username = $f7route.params.username;
      const token = store.state.token;
      const server = store.state.server;
      const container = document.getElementById("profile-room-content");

      try {
        const res = await fetch(`${server}/room/${username}`, {
          headers: { Authorization: `Bearer ${token}` },
        });
        const html = await res.text();
        originalRoomHtml = html;
        container.innerHTML = html;
      } catch {
        container.innerHTML = "<p>Failed to load room.</p>";
        return;
      }

      let userData = getCachedUser(username) || { username };
      try {
        const res = await fetch(`${server}/users/${username}`, {
          headers: { Authorization: `Bearer ${token}` },
        });
        if (res.ok) {
          userData = await res.json();
          await store.dispatch("cacheUserData", userData);
        }
      } catch {}

      currentUserData = userData;
      await renderCustomTags(container, username, userData);

      const editBtn = document.querySelector(".edit-toggle");
      editBtn.addEventListener("click", async (e) => {
        e.preventDefault();
        if (!editMode) {
          editMode = true;
          editBtn.innerText = "Save";
          enterEditMode(container);
        } else {
          await saveEdits(container);
          editMode = false;
          editBtn.innerText = "Edit";
          container.innerHTML = originalRoomHtml;
          await renderCustomTags(container, username, currentUserData);
        }
      });
    });

    return $render;
  };
</script>

<style>
  .navbar .right {
    position: absolute;
    right: 10px;
    top: 50%;
    transform: translateY(-50%);
  }
  .navbar .edit-toggle {
    color: #007aff;
    font-weight: bold;
    cursor: pointer;
  }
</style>
