<template>
  <div class="page">
    <!-- <div class="navbar">
      <div class="navbar-inner">
        <div class="title">Gallery</div>
      </div>
    </div> -->
    <div class="page-content" id="galleryContainer"></div>
  </div>
</template>

<script>
  import store from "../js/store.js";
  import localforage from "localforage";
  import "fslightbox";

  export default (props, { $f7, $onMounted }) => {
    $onMounted(async () => {
      const token = store.state.token;
      const server = store.state.server;
      const container = document.getElementById("galleryContainer");
      if (!token) {
        console.log("[Gallery] No token, redirecting to login");
        $f7.views.main.router.navigate("/login");
        return;
      }
      if (!container) {
        console.warn("[Gallery] No container found");
        return;
      }

      const isImage = (f) => /\.(jpe?g|png|gif|webp|bmp)$/i.test(f);
      const isVideo = (f) => /\.(mp4|webm|mov|avi|mkv)$/i.test(f);

      const cached = await localforage.getItem("gallery");
      if (cached) {
        console.log("[Gallery] Using cached data");
        renderGallery(cached);
      }

      try {
        const res = await fetch(`${server}/gallery`, {
          headers: { Authorization: `Bearer ${token}` },
        });
        if (!res.ok) throw new Error("Failed to fetch gallery");
        const data = await res.json();
        console.log("[Gallery] Data fetched:", data);
        await localforage.setItem("gallery", data);
        renderGallery(data);
      } catch (err) {
        console.error("[Gallery] Load error:", err);
        container.innerHTML = `<p style="padding: 1rem; color: red;">Failed to load gallery.</p>`;
      }

      function renderGallery(grouped) {
        console.log("[Gallery] Rendering...");

        let selectionMode = false;
        let selectedItems = new Set();
        let dragStartIndex = null;
        let dragEndIndex = null;
        let isDragging = false;
        let baseSelection = new Set();

        container.innerHTML = "";

        const topbar = document.createElement("div");
        topbar.className = "gallery-topbar";
        topbar.style.display = "none";
        topbar.innerHTML = `
					<span class="gallery-close">âœ•</span>
					<span class="gallery-count">0 selected</span>
					<div class="gallery-actions">
						<i class="f7-icons action-icon" title="Edit Date" id="editDateBtn">calendar</i>
						<i class="f7-icons action-icon" title="Add to Album">folder_badge_plus</i>
						<i class="f7-icons action-icon" title="Trash">trash</i>
					</div>
				`;
        container.before(topbar);
        console.log("[Gallery] Topbar inserted");

        topbar.querySelector(".gallery-close").onclick = () => clearSelection();

        const editBtn = topbar.querySelector("#editDateBtn");
        if (editBtn) {
          console.log("[Gallery] Edit Date button found");
          editBtn.addEventListener("click", () => {
            console.log("[Gallery] Edit Date button clicked");

            const dialog = document.createElement("div");
            dialog.className = "edit-dialog";
            dialog.innerHTML = `
							<div class="dialog-overlay"></div>
							<div class="dialog-box">
								<h3>Edit Date</h3>
								<label>Date: <input type="date" id="edit-date-input" required></label>
								<label>Time: <input type="time" id="edit-time-input" required></label>
								<div class="dialog-buttons">
									<button id="cancel-edit">Cancel</button>
									<button id="confirm-edit">Save</button>
								</div>
							</div>
						`;
            document.body.appendChild(dialog);
            console.log("[Gallery] Edit dialog opened");

            dialog.querySelector("#cancel-edit").onclick = () => {
              console.log("[Gallery] Edit cancelled");
              dialog.remove();
            };

            dialog.querySelector("#confirm-edit").onclick = async () => {
              const date = dialog.querySelector("#edit-date-input").value;
              const time = dialog.querySelector("#edit-time-input").value;
              if (!date || !time) {
                alert("Please enter both date and time.");
                return;
              }
              const datetime = new Date(`${date}T${time}`);
              const timestamp = Math.floor(datetime.getTime() / 1000);
              console.log(`[Gallery] Saving new timestamp: ${timestamp}`);

              for (const filename of selectedItems) {
                console.log(`[Gallery] Updating ${filename}`);
                await fetch(`${server}/edit-date`, {
                  method: "POST",
                  headers: {
                    "Content-Type": "application/json",
                    Authorization: `Bearer ${token}`,
                  },
                  body: JSON.stringify({
                    filename,
                    new_timestamp: timestamp,
                  }),
                });
              }
              dialog.remove();
              $f7.views.main.router.refreshPage();
            };
          });
        } else {
          console.warn("[Gallery] Edit Date button not found!");
        }

        function updateUIState() {
          console.log("[Gallery] Selection size:", selectedItems.size);
          topbar.style.display = selectionMode ? "flex" : "none";
          topbar.querySelector(
            ".gallery-count"
          ).textContent = `${selectedItems.size} selected`;
          document.body.classList.toggle("selection-mode", selectionMode);
        }

        function clearSelection() {
          console.log("[Gallery] Clearing selection");
          selectionMode = false;
          selectedItems.clear();
          document
            .querySelectorAll(".media-tile.selected")
            .forEach((t) => t.classList.remove("selected"));
          updateUIState();
        }

        let allItems = Object.entries(grouped)
          .flatMap(([month, items]) =>
            items.map((item) => ({
              ...item,
              month,
              sort_time: item.date_taken || item.timestamp,
            }))
          )
          .sort((a, b) => b.sort_time - a.sort_time);

        const sortedByMonth = {};
        allItems.forEach((item) => {
          if (!sortedByMonth[item.month]) sortedByMonth[item.month] = [];
          sortedByMonth[item.month].push(item);
        });

        const observer = new IntersectionObserver(
          (entries) => {
            entries.forEach((entry) => {
              if (entry.isIntersecting) {
                const img = entry.target;
                img.src = img.dataset.src;
                observer.unobserve(img);
              }
            });
          },
          { rootMargin: "100px", threshold: 0.1 }
        );

        const tileElements = [];

        for (const [month, items] of Object.entries(sortedByMonth)) {
          const header = document.createElement("div");
          header.className = "gallery-month-header";
          header.textContent = month;
          container.appendChild(header);

          const grid = document.createElement("div");
          grid.className = "gallery-grid";
          container.appendChild(grid);

          items.forEach((item) => {
            const fullSrc = `${server}/uploads/${item.filename}`;
            const baseName = item.filename.split(".")[0];
            const isImg = isImage(item.filename);
            const isVid = isVideo(item.filename);
            const previewSrc = isVid
              ? `${server}/uploads/preview_${baseName}.jpg`
              : `${server}/uploads/preview_${item.filename}`;

            const anchor = document.createElement("a");
            anchor.href = fullSrc;
            anchor.classList.add("external");
            anchor.setAttribute("data-fslightbox", "gallery");
            anchor.draggable = false;
            anchor.addEventListener("click", (e) => {
              if (selectionMode) {
                e.preventDefault();
                e.stopImmediatePropagation();
              }
            });

            // Prevent long-press menu on Android
            anchor.addEventListener("contextmenu", (e) => e.preventDefault());

            const img = document.createElement("img");
            img.dataset.src = previewSrc;
            img.alt = item.caption || "";
            img.draggable = false;
            img.onerror = () => console.error("Failed preview:", previewSrc);

            // Prevent long-press menu on Android
            img.addEventListener("contextmenu", (e) => e.preventDefault());

            observer.observe(img);

            const tile = document.createElement("div");
            tile.className = "media-tile";
            tile.dataset.index = tileElements.length;
            tile.dataset.filename = item.filename;
            tileElements.push(tile);

            const checkCircle = document.createElement("div");
            checkCircle.className = "check-circle";
            checkCircle.innerHTML = `<i class="f7-icons">checkmark_circle_fill</i>`;
            tile.appendChild(checkCircle);

            let holdTimer = null;
            let longPressed = false;

            let inverseMode = false; // ðŸ”¹ Add at top of renderGallery

            tile.addEventListener("pointerdown", (e) => {
              e.preventDefault();
              e.stopPropagation();
              longPressed = false;
              isDragging = false;

              inverseMode = e.altKey || e.metaKey; // âœ… hold Alt or Command for inverse mode

              holdTimer = setTimeout(() => {
                longPressed = true;
                if (!selectionMode) {
                  console.log("[Gallery] Entering selection mode");
                  selectionMode = true;
                  updateUIState();
                }
                isDragging = true;
                dragStartIndex = Number(tile.dataset.index);
                dragEndIndex = dragStartIndex;

                baseSelection = new Set(selectedItems);
                selectedItems = new Set(baseSelection);

                if (inverseMode) {
                  if (selectedItems.has(item.filename)) {
                    selectedItems.delete(item.filename);
                    tile.classList.remove("selected");
                  } else {
                    selectedItems.add(item.filename);
                    tile.classList.add("selected");
                  }
                } else {
                  selectedItems.add(item.filename);
                  tile.classList.add("selected");
                }
                updateUIState();
              }, 500);
            });

            tile.addEventListener("pointerenter", () => {
              if (!isDragging || dragStartIndex === null) return;
              dragEndIndex = Number(tile.dataset.index);
              const [min, max] = [dragStartIndex, dragEndIndex].sort(
                (a, b) => a - b
              );

              selectedItems = new Set(baseSelection); // Start from base
              tileElements.forEach((el, i) => {
                const fname = el.dataset.filename;
                const inRange = i >= min && i <= max;

                if (inRange) {
                  if (inverseMode) {
                    if (baseSelection.has(fname)) {
                      selectedItems.delete(fname);
                      el.classList.remove("selected");
                    } else {
                      selectedItems.add(fname);
                      el.classList.add("selected");
                    }
                  } else {
                    selectedItems.add(fname);
                    el.classList.add("selected");
                  }
                } else {
                  if (!selectedItems.has(fname)) {
                    el.classList.remove("selected");
                  }
                }
              });
              updateUIState();
            });

            tile.addEventListener("pointerup", () => {
              clearTimeout(holdTimer);

              if (!longPressed && !isDragging && selectionMode) {
                const isSelected = selectedItems.has(item.filename);
                if (isSelected) {
                  selectedItems.delete(item.filename);
                  tile.classList.remove("selected");
                } else {
                  selectedItems.add(item.filename);
                  tile.classList.add("selected");
                }
                if (selectedItems.size === 0) selectionMode = false;
                updateUIState();
              }

              isDragging = false;
              dragStartIndex = null;
              dragEndIndex = null;
            });

            tile.addEventListener("pointerleave", () =>
              clearTimeout(holdTimer)
            );

            if (isVid) {
              const icon = document.createElement("div");
              icon.className = "media-icon";
              icon.innerHTML = `<i class="f7-icons">play_circle_fill</i>`;
              anchor.appendChild(icon);
            }

            anchor.appendChild(img);
            tile.appendChild(anchor);
            grid.appendChild(tile);
          });
        }

        window.addEventListener("pointerup", () => {
          isDragging = false;
          dragStartIndex = null;
          dragEndIndex = null;
        });

        if (typeof refreshFsLightbox === "function") {
          refreshFsLightbox();
        } else {
          console.warn("[Gallery] FsLightbox not ready yet.");
        }
      }
    });
    return $render;
  };
</script>

<style>
  .page-content {
    padding-bottom: 80px;
  }

  .gallery-topbar {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 0.75rem 1rem;
    background: #111;
    color: #fff;
    font-size: 1rem;
    z-index: 1000;
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
  }

  .gallery-topbar .gallery-close {
    font-size: 1.2rem;
    cursor: pointer;
    user-select: none;
  }

  .gallery-topbar .gallery-actions {
    display: flex;
    gap: 0.75rem;
    align-items: center;
  }

  .gallery-topbar .action-icon {
    cursor: pointer;
    font-size: 1.2rem;
    opacity: 0.85;
    transition: opacity 0.2s;
  }

  .gallery-topbar .action-icon:hover {
    opacity: 1;
  }

  .gallery-month-header {
    font-size: 1.25rem;
    font-weight: bold;
    margin: 1rem 1rem 0.5rem;
    color: #d2d2d2;
    border-bottom: 1px solid #ccc;
    padding-bottom: 0.25rem;
  }

  .gallery-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
    gap: 8px;
    padding: 0 1rem 1rem;
  }

  .media-tile {
    position: relative;
    user-select: none;
    -webkit-user-drag: none;
  }

  .media-tile img {
    width: 100%;
    height: 100%;
    object-fit: cover;
    border-radius: 8px;
    cursor: pointer;
    aspect-ratio: 1 / 1;
    background: #f0f0f0;
  }

  .media-icon {
    position: absolute;
    bottom: 4px;
    right: 4px;
    background: rgba(0, 0, 0, 0.6);
    border-radius: 50%;
    padding: 4px;
    color: white;
    font-size: 16px;
    pointer-events: none;
  }

  .check-circle {
    display: none;
    position: absolute;
    top: 6px;
    left: 6px;
    width: 20px;
    height: 20px;
    border-radius: 50%;
    border: 2px solid white;
    background: rgba(0, 0, 0, 0.4);
    z-index: 10;
  }

  .media-tile.selected .check-circle,
  .selection-mode .media-tile .check-circle {
    display: block;
  }

  .media-tile.selected {
    border: 2px solid #007aff;
    box-shadow: 0 0 4px #007aff;
  }

  .check-circle i {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    margin: auto;
    width: 100%;
    height: 100%;
    font-size: 20px;
    color: #007aff;
    display: none;
  }

  .media-tile.selected .check-circle i {
    display: block;
  }

  #galleryContainer {
    user-select: none;
  }
  .edit-dialog {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 9999999;
  }

  .edit-dialog .dialog-overlay {
    position: absolute;
    inset: 0;
    background: rgba(0, 0, 0, 0.5);
  }

  .edit-dialog .dialog-box {
    position: relative;
    background: #fff;
    color: #000;
    padding: 1rem;
    border-radius: 12px;
    z-index: 1;
    width: 90%;
    max-width: 320px;
    box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
  }

  .dialog-box h3 {
    margin-top: 0;
    font-size: 1.2rem;
  }

  .dialog-box label {
    display: block;
    margin: 0.5rem 0;
  }

  .dialog-buttons {
    display: flex;
    justify-content: flex-end;
    gap: 0.5rem;
    margin-top: 1rem;
  }

  .dialog-buttons button {
    padding: 0.5rem 1rem;
    border: none;
    border-radius: 6px;
    background: #007aff;
    color: #fff;
    cursor: pointer;
    font-weight: bold;
  }
  .dialog-buttons button#cancel-edit {
    background: #aaa;
  }
</style>
